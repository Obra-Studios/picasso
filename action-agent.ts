// ============================================================================
// ACTION AGENT
// Translates context + intent into concrete actions and constraints
// ============================================================================

import type { CanvasObject } from './constraints';

// ============================================================================
// INPUT TYPES
// ============================================================================

/**
 * Static context generated by the context agent
 * Contains design system and environmental information
 */
export interface Context {
  /** Design system colors */
  colors: {
    primary: string;
    secondary: string;
    accent: string;
    background: string;
    text: string;
    [key: string]: string;
  };
  
  /** Design system spacing scale */
  spacing: {
    xs: number;
    sm: number;
    md: number;
    lg: number;
    xl: number;
    [key: string]: number;
  };
  
  /** Typography system */
  typography: {
    fontSize: {
      xs: number;
      sm: number;
      md: number;
      lg: number;
      xl: number;
      [key: string]: number;
    };
    fontFamily: {
      primary: string;
      secondary: string;
      [key: string]: string;
    };
  };
  
  /** Design tokens and preferences */
  designTokens?: Record<string, any>;
}

/**
 * Current state of the DOM/canvas
 */
export interface DOMState {
  /** All objects currently on the canvas */
  objects: CanvasObject[];
  
  /** Canvas dimensions */
  viewport: {
    width: number;
    height: number;
  };
  
  /** Currently selected objects (if any) */
  selection?: string[];
}

/**
 * User intent interpreted by the intent agent
 */
export type Intent = string;

// ============================================================================
// OUTPUT TYPES
// ============================================================================

/**
 * Action type enumeration
 * Each action represents a single atomic operation
 */
export type ActionType =
  | 'create'      // Create a new element
  | 'move';       // Move an existing element

/**
 * Element types that can be created
 */
export type ElementType =
  | 'rectangle'
  | 'ellipse'
  | 'text'
  | 'frame'
  | 'line'
  | 'polygon';

/**
 * Single concrete action to be performed
 * Each action operates on a single asset
 */
export interface Action {
  /** Unique identifier for this action */
  id: string;
  
  /** Type of action to perform */
  type: ActionType;
  
  /** 
   * Natural language description of what needs to be done
   * Should be very concrete and specific to a single asset
   * Example: "Create a blue rectangle inside the parent container at position (50, 100)"
   * The execution agent will use this description to generate the actual parameters
   */
  description: string;
  
  /** 
   * Target object ID (for modify operations like move)
   * Undefined for create operations
   */
  targetId?: string;
  
  /**
   * Constraints that must be satisfied for this action
   * These provide exact bounds and rules the execution agent must follow
   */
  constraints: Constraint[];
}

// ============================================================================
// CONSTRAINT TYPES
// ============================================================================

/**
 * Constraint type enumeration
 */
export type ConstraintType =
  | 'position'   // X/Y position constraints
  | 'size'       // Width/height constraints
  | 'spacing'    // Spacing between elements
  | 'color'      // Color matching constraints
  | 'alignment'; // Alignment constraints

/**
 * Constraint operator for comparisons
 */
export type ConstraintOperator =
  | 'eq'  // Equal to
  | 'gt'  // Greater than
  | 'gte' // Greater than or equal
  | 'lt'  // Less than
  | 'lte'; // Less than or equal

/**
 * Single constraint that must be satisfied
 */
export interface Constraint {
  /** Unique identifier */
  id: string;
  
  /** Type of constraint */
  type: ConstraintType;
  
  /** 
   * Natural language description
   * Example: "Box must be inside parent container with 16px padding"
   */
  description: string;
  
  /** ID of the object this constraint applies to */
  targetId: string;
  
  /** Constraint-specific parameters */
  parameters: ConstraintParameters;
}

/**
 * Parameters for different constraint types
 */
export type ConstraintParameters =
  | PositionConstraint
  | SizeConstraint
  | SpacingConstraint
  | ColorConstraint
  | AlignmentConstraint;

export interface PositionConstraint {
  type: 'position';
  /** Container ID - element must be positioned within this container */
  containerId?: string;
  /** Padding from container edges */
  padding?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
  /** X position constraint */
  x?: {
    operator: ConstraintOperator;
    value: number;
  };
  /** Y position constraint */
  y?: {
    operator: ConstraintOperator;
    value: number;
  };
  /** Range constraints for position (calculated from containerId + padding + size) */
  xRange?: {
    min: number;
    max: number;
  };
  yRange?: {
    min: number;
    max: number;
  };
}

export interface SizeConstraint {
  type: 'size';
  /** Width constraint */
  width?: {
    operator: ConstraintOperator;
    value: number;
  };
  /** Height constraint */
  height?: {
    operator: ConstraintOperator;
    value: number;
  };
  /** Aspect ratio constraint (width/height) */
  aspectRatio?: number;
}

export interface SpacingConstraint {
  type: 'spacing';
  /** ID of reference object */
  referenceId: string;
  /** Direction of spacing */
  direction: 'horizontal' | 'vertical';
  /** Distance constraint */
  distance: {
    operator: ConstraintOperator;
    value: number;
  };
}

export interface ColorConstraint {
  type: 'color';
  /** Color property to constrain */
  property: 'fill' | 'stroke';
  /** Exact color value or reference */
  value: string;
  /** Alternative: match another object's color */
  matchObjectId?: string;
}

export interface AlignmentConstraint {
  type: 'alignment';
  /** Alignment type */
  alignment: 'left' | 'right' | 'top' | 'bottom' | 'center-x' | 'center-y';
  /** ID of reference object or group */
  referenceId?: string;
  /** Coordinate value if absolute */
  coordinate?: number;
}

// ============================================================================
// AGENT OUTPUT
// ============================================================================

/**
 * Complete output from the action agent
 */
export interface ActionAgentOutput {
  /** List of concrete actions to perform, each with their own constraints */
  actions: Action[];
  
  /** Metadata about the generation */
  metadata: {
    /** Timestamp */
    timestamp: number;
    
    /** Model used for generation */
    model: string;
    
    /** Original intent */
    intent: string;
  };
}

// ============================================================================
// ACTION AGENT IMPLEMENTATION
// ============================================================================

/**
 * Generate actions and constraints from context, state, and intent
 * 
 * @param context - Static context from context agent
 * @param domState - Current DOM state
 * @param intent - User intent from intent agent
 * @param apiKey - Optional OpenAI API key (defaults to OPENAI_API_KEY env var)
 * @returns Actions and constraints to execute
 */
export async function generateActions(
  context: Context,
  domState: DOMState,
  intent: Intent,
  apiKey?: string
): Promise<ActionAgentOutput> {
  // Get API key from parameter or environment variable (Bun automatically loads .env)
  const key = apiKey || (typeof Bun !== 'undefined' ? Bun.env.OPENAI_API_KEY : undefined);
  
  if (!key) {
    throw new Error('OpenAI API key is required. Set OPENAI_API_KEY in .env file or pass it as a parameter.');
  }
  const prompt = buildActionPrompt(context, domState, intent);
  const schema = getActionSchema();
  
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${key}`,
    },
    body: JSON.stringify({
      model: 'gpt-4o-2024-08-06',
      messages: [
        {
          role: 'system',
          content: getSystemPrompt(),
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
      response_format: {
        type: 'json_schema',
        json_schema: {
          name: 'action_agent_output',
          strict: false,
          schema: schema,
        },
      },
      temperature: 0.2,
    }),
  });

  if (!response.ok) {
    const error = await response.json() as any;
    throw new Error(`Action generation failed: ${error.error?.message || 'Unknown error'}`);
  }

  const data = await response.json() as any;
  const content = data.choices[0]?.message?.content;
  
  if (!content) {
    throw new Error('No content in response');
  }

  const parsed = JSON.parse(content);
  
  // Enrich constraints within each action with exact DOM values
  const actionsWithEnrichedConstraints = (parsed.actions || []).map((action: any) => ({
    ...action,
    constraints: enrichConstraintsWithDOMValues(action.constraints || [], domState),
  }));
  
  return {
    actions: actionsWithEnrichedConstraints,
    metadata: {
      timestamp: Date.now(),
      model: 'gpt-4o-2024-08-06',
      intent,
    },
  };
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Enrich constraints with exact values calculated from DOM state
 * Position constraints are enriched based on size constraints
 */
export function enrichConstraintsWithDOMValues(
  constraints: Constraint[],
  domState: DOMState
): Constraint[] {
  // First pass: enrich non-position constraints
  const enrichedNonPosition = constraints.map(constraint => {
    switch (constraint.type) {
      case 'spacing':
        return enrichSpacingConstraint(constraint, domState);
      case 'position':
        return constraint; // Handle in second pass
      default:
        return constraint;
    }
  });
  
  // Second pass: enrich position constraints based on size constraints
  return enrichedNonPosition.map(constraint => {
    if (constraint.type === 'position') {
      return enrichPositionConstraint(constraint, enrichedNonPosition, domState);
    }
    return constraint;
  });
}

/**
 * Enrich position constraint with concrete range values based on parent container and size constraints
 * Calculates xRange/yRange from containerId + padding + size constraint
 * maxX = containerX + containerWidth - padding.right - elementWidth
 * maxY = containerY + containerHeight - padding.bottom - elementHeight
 */
function enrichPositionConstraint(
  constraint: Constraint,
  allConstraints: Constraint[],
  domState: DOMState
): Constraint {
  const params = constraint.parameters as PositionConstraint;
  const targetId = constraint.targetId;
  
  // If containerId is present, we should ALWAYS recalculate xRange/yRange from it
  // This takes precedence over any existing xRange/yRange values
  const shouldRecalculate = params.containerId !== undefined;
  
  // If no containerId and xRange/yRange are already concrete numeric values, return as-is
  if (
    !shouldRecalculate &&
    params.xRange &&
    params.yRange &&
    typeof params.xRange.min === 'number' &&
    typeof params.xRange.max === 'number' &&
    typeof params.yRange.min === 'number' &&
    typeof params.yRange.max === 'number'
  ) {
    return constraint;
  }
  
  // Get container from containerId parameter
  let container: CanvasObject | undefined;
  
  if (params.containerId) {
    container = findObject(domState, params.containerId);
  } else {
    // Try to extract from string formulas (legacy support)
    const parentId = extractParentIdFromRangeParams(params.xRange, params.yRange, domState);
    if (parentId) {
      container = findObject(domState, parentId);
    } else {
      // Fall back to target's parentId
      const target = findObject(domState, targetId);
      if (target?.parentId) {
        container = findObject(domState, target.parentId);
      }
    }
  }
  
  if (!container) {
    return constraint;
  }
  
  // Get padding values
  let padding = {
    top: params.padding?.top || 0,
    right: params.padding?.right || 0,
    bottom: params.padding?.bottom || 0,
    left: params.padding?.left || 0,
  };
  
  // If no padding specified, try to extract from formulas (legacy)
  if (!params.padding && (params.xRange || params.yRange)) {
    padding = extractPaddingFromRangeParams(params.xRange, params.yRange);
  }
  
  // Find size constraint for the same target to get width/height
  const sizeConstraint = allConstraints.find(
    c => c.type === 'size' && c.targetId === targetId
  );
  const sizeParams = sizeConstraint?.parameters as SizeConstraint | undefined;
  
  // Get element width and height from size constraint or existing object
  let elementWidth = 0;
  let elementHeight = 0;
  
  if (sizeParams) {
    elementWidth = sizeParams.width?.value || 0;
    elementHeight = sizeParams.height?.value || 0;
  } else {
    const target = findObject(domState, targetId);
    if (target) {
      elementWidth = target.width || 0;
      elementHeight = target.height || 0;
    }
  }
  
  // Calculate concrete position ranges
  // Position is measured from top-left corner, so max = containerMax - padding - elementSize
  const xRange = {
    min: container.x + padding.left,
    max: container.x + container.width - padding.right - elementWidth,
  };
  
  const yRange = {
    min: container.y + padding.top,
    max: container.y + container.height - padding.bottom - elementHeight,
  };
  
  return {
    ...constraint,
    parameters: {
      ...params,
      xRange,
      yRange,
    },
  };
}

/**
 * Extract parent ID from range parameters (handles string formulas or object IDs)
 */
function extractParentIdFromRangeParams(
  xRange: any,
  yRange: any,
  domState: DOMState
): string | null {
  // Check if min/max contain references to DOM objects
  const rangeStr = JSON.stringify(xRange || yRange || {});
  
  // Look for patterns like "obj-3", "contentArea", "content-area"
  for (const obj of domState.objects) {
    if (rangeStr.includes(obj.id) || 
        rangeStr.toLowerCase().includes(obj.name.toLowerCase().replace(/\s+/g, '-')) ||
        rangeStr.toLowerCase().includes(obj.name.toLowerCase().replace(/\s+/g, ''))) {
      return obj.id;
    }
  }
  
  return null;
}

/**
 * Extract padding values from range formulas
 */
function extractPaddingFromRangeParams(xRange: any, yRange: any): {
  top: number;
  right: number;
  bottom: number;
  left: number;
} {
  const rangeStr = JSON.stringify({ xRange, yRange });
  
  // Look for numeric values after + or - operators
  const plusMatches = rangeStr.match(/\+\s*(\d+)/g);
  const minusMatches = rangeStr.match(/\-\s*(\d+)/g);
  
  let padding = 0;
  if (plusMatches && plusMatches.length > 0) {
    padding = parseInt(plusMatches[0].replace(/[+\s]/g, ''), 10);
  } else if (minusMatches && minusMatches.length > 0) {
    padding = parseInt(minusMatches[0].replace(/[-\s]/g, ''), 10);
  }
  
  return {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding,
  };
}

/**
 * Enrich spacing constraint with exact distances
 */
function enrichSpacingConstraint(
  constraint: Constraint,
  domState: DOMState
): Constraint {
  const params = constraint.parameters as SpacingConstraint;
  const target = findObject(domState, constraint.targetId);
  const reference = findObject(domState, params.referenceId);
  
  if (!target || !reference) {
    return constraint;
  }
  
  // Calculate actual distance based on direction
  let actualDistance: number;
  
  if (params.direction === 'horizontal') {
    actualDistance = Math.abs(
      (target.x < reference.x)
        ? reference.x - (target.x + target.width)
        : target.x - (reference.x + reference.width)
    );
  } else {
    actualDistance = Math.abs(
      (target.y < reference.y)
        ? reference.y - (target.y + target.height)
        : target.y - (reference.y + reference.height)
    );
  }
  
  return {
    ...constraint,
    parameters: {
      ...params,
      distance: {
        ...params.distance,
        value: actualDistance,
      },
    },
  };
}

/**
 * Build the prompt for action generation
 */
function buildActionPrompt(
  context: Context,
  domState: DOMState,
  intent: Intent
): string {
  return `You are an action agent that translates user intent into concrete design actions and constraints.

**USER INTENT:**
${intent}

**DESIGN CONTEXT:**
- Colors: ${JSON.stringify(context.colors, null, 2)}
- Spacing: ${JSON.stringify(context.spacing, null, 2)}
- Typography: ${JSON.stringify(context.typography, null, 2)}

**CURRENT DOM STATE:**
- Canvas: ${domState.viewport.width}×${domState.viewport.height}
- Objects: ${domState.objects.length} total
${domState.objects.slice(0, 10).map(obj => 
  `  • ${obj.name} (${obj.type}): position (${obj.x}, ${obj.y}), size ${obj.width}×${obj.height}`
).join('\n')}
${domState.objects.length > 10 ? `  ... and ${domState.objects.length - 10} more objects` : ''}

**YOUR TASK:**
1. Break down the intent into atomic actions (one per asset)
2. Generate constraints WITH specific parameters based on the DOM state and design system
3. Each action should have a clear, concrete description in natural language
4. DO NOT generate specific parameters in the action itself (positions, sizes, colors) - the execution agent will do that
5. DO generate specific constraint parameters (containerId, padding values, spacing distances, color references, etc.)
6. Focus on WHAT needs to be done (action description) and the RULES (constraint parameters)
7. For position constraints: ONLY specify containerId and padding - DO NOT include xRange or yRange
8. The system will automatically calculate xRange/yRange from containerId + padding + size constraints

**EXAMPLES:**
- Action: "Create an email input field inside the Content Area"
  Constraints: 
    - position: { containerId: 'obj-3', padding: { top: 16, right: 16, bottom: 16, left: 16 } }
      (System will calculate xRange/yRange automatically)
    - size: { width: { operator: 'eq', value: 200 }, height: { operator: 'eq', value: 40 } }
  
- Action: "Create a login button below the email input field"
  Constraints:
    - spacing: { referenceId: 'email-input', direction: 'vertical', distance: { operator: 'eq', value: 12 } }
    - size: { width: { operator: 'eq', value: 100 }, height: { operator: 'eq', value: 40 } }
    - color: { property: 'fill', value: 'primary' }
    
- Action: "Move the Button into the Header Container aligned to the right"
  Constraints:
    - position: { containerId: 'obj-1', padding: { right: 16 } }
      (System will calculate xRange/yRange automatically)
    - alignment: { alignment: 'right', referenceId: 'obj-1' }

**IMPORTANT:**
- One action per asset/operation
- Action description: WHAT to do (natural language, no coordinates/sizes/colors)
- Constraint parameters: SPECIFIC VALUES (padding: 16, spacing: 12, color: 'primary', etc.)
- Use design system values in constraints (spacing.md=16, spacing.lg=24, colors.primary, etc.)
- Constraints provide the rules; execution agent calculates exact Figma parameters from them`;
}

/**
 * System prompt for the action agent
 */
function getSystemPrompt(): string {
  return `You are an expert action agent for a design tool. You translate high-level user intents into concrete actions with constraints. Your role is to determine WHAT needs to be done and the CONSTRAINTS that must be satisfied - NOT the specific parameters. The execution agent will handle generating exact positions, sizes, and colors based on your constraints. Focus on spatial relationships, containment, alignment, and spacing requirements.`;
}

/**
 * JSON schema for structured output
 */
function getActionSchema() {
  return {
    type: 'object',
    properties: {
      actions: {
        type: 'array',
        description: 'List of concrete actions to perform',
        items: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              description: 'Unique identifier for this action',
            },
            type: {
              type: 'string',
              enum: ['create', 'move'],
              description: 'Type of action',
            },
            description: {
              type: 'string',
              description: 'Natural language description of what this action does',
            },
            targetId: {
              type: 'string',
              description: 'Target object ID (for modify operations)',
            },
            constraints: {
              type: 'array',
              description: 'Constraints that must be satisfied for this action',
              items: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'Unique identifier for this constraint',
                  },
                  type: {
                    type: 'string',
                    enum: ['position', 'size', 'spacing', 'color', 'alignment'],
                    description: 'Type of constraint',
                  },
                  description: {
                    type: 'string',
                    description: 'Natural language description of this constraint',
                  },
                  targetId: {
                    type: 'string',
                    description: 'ID of the object this constraint applies to',
                  },
                  parameters: {
                    type: 'object',
                    description: 'Constraint-specific parameters',
                    properties: {},
                    additionalProperties: true,
                  },
                },
                required: ['id', 'type', 'description', 'targetId', 'parameters'],
                additionalProperties: false,
              },
            },
          },
          required: ['id', 'type', 'description', 'constraints'],
          additionalProperties: false,
        },
      },
    },
    required: ['actions'],
    additionalProperties: false,
  };
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Validate that an action is well-formed
 */
export function validateAction(action: Action): boolean {
  if (!action.id || !action.type || !action.description) {
    return false;
  }
  
  // Constraints array should exist (can be empty)
  if (!Array.isArray(action.constraints)) {
    return false;
  }
  
  return true;
}

/**
 * Validate that a constraint is well-formed
 */
export function validateConstraint(constraint: Constraint): boolean {
  if (!constraint.id || !constraint.type || !constraint.description || 
      !constraint.targetId || !constraint.parameters) {
    return false;
  }
  
  if (constraint.parameters.type !== constraint.type) {
    return false;
  }
  
  return true;
}

/**
 * Find an object in the DOM state by ID
 */
export function findObject(domState: DOMState, id: string): CanvasObject | undefined {
  return domState.objects.find(obj => obj.id === id);
}

/**
 * Get all children of a parent object
 */
export function getChildren(domState: DOMState, parentId: string): CanvasObject[] {
  return domState.objects.filter(obj => obj.parentId === parentId);
}

/**
 * Calculate bounding box for a set of objects
 */
export function getBoundingBox(objects: CanvasObject[]): {
  x: number;
  y: number;
  width: number;
  height: number;
} {
  if (objects.length === 0) {
    return { x: 0, y: 0, width: 0, height: 0 };
  }
  
  const minX = Math.min(...objects.map(obj => obj.x));
  const minY = Math.min(...objects.map(obj => obj.y));
  const maxX = Math.max(...objects.map(obj => obj.x + obj.width));
  const maxY = Math.max(...objects.map(obj => obj.y + obj.height));
  
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY,
  };
}
